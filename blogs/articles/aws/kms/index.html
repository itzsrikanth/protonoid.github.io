<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>KMS Encryption and Decryption</title><meta name="description" content="Encrypt and decrypt secure text, passwords and keys using AWS KMS service using CLI"/><meta charset="utf-8"/><meta name="viewport" content="initial-scale=1.0, width=device-width"/><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><meta name="next-head-count" content="6"/><link rel="preload" href="/_next/static/css/commons.be16d001.chunk.css" as="style"/><link rel="stylesheet" href="/_next/static/css/commons.be16d001.chunk.css"/><link rel="preload" href="/_next/static/c_R24dhd8hjJEXWGIGUO-/pages/articles.js" as="script"/><link rel="preload" href="/_next/static/c_R24dhd8hjJEXWGIGUO-/pages/_app.js" as="script"/><link rel="preload" href="/_next/static/runtime/webpack-9369c5c69dbf6d4912cb.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.b6dc333151af4a74b05a.js" as="script"/><link rel="preload" href="/_next/static/runtime/main-5b3d9dcbbf35909ee5a1.js" as="script"/></head><body><div id="__next"><nav class="d-flex align-items-center"><div class="container"><ul><li><a href="/blogs">Blogs</a></li></ul></div></nav><div class="container"><div><h1 id="encrypt-and-decrypt-keys-using-aws-kms">Encrypt and Decrypt Keys using AWS KMS</h1>
<h2 id="encryption">Encryption</h2>
<p>For this we need to create a &quot;Customer Managed Key&quot; using either console or CLI, or any other programmatic way. Once we do that, we obtain a <code>key-id</code> to use for encryption. We do not require <code>key-id</code> for decryption. The reason is that, the encrypted hash will be self sufficiently having all the required data for decryption. We can set alias name and description for the keys along with tags for easy identification of the key&#39;s purpose.</p>
<pre><code class="language-bash">aws kms encrypt \
--key-id XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX \
--plaintext &quot;secret text for encryption&quot; \
--output text \
--query CiphertextBlob</code></pre>
<p>The drawback with above method is, if someone or admin checks the history, it will be visible as clear text and in many organisation it will be a clear violation of security policies. For that, we can store the password in a text file and call that file here. Say,</p>
<pre><code class="language-bash">aws kms encrypt \
--key-id XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX \
--plaintext fileb://secretfile \
--output text \
--query CiphertextBlob</code></pre>
<p>When we do this, the resulting hash will be <code>base64</code> encoded. If we decode it, it will result in a binary value which we cannot store in yaml file. Or else, we can have the binary string written to a separate file and reference that file in our yaml files.
For decoding and storing in a file,</p>
<pre><code class="language-bash">aws kms encrypt \
--key-id XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX \
--plaintext fileb://secretfile \
--output text \
--query CiphertextBlob | base64 --decode &gt; binaryFileName</code></pre>
<h2 id="decryption">Decryption</h2>
<p>For decryption,</p>
<pre><code class="language-bash">aws kms decrypt \
--ciphertext-blob fileb://binaryFileName
--output text \
--query Plaintext</code></pre>
<p><strong>Note:- Again, the resulting text will be base64 encoded</strong></p>
<p>If you have an encrypted base64 text string to obtain back the original secret key, you can do:</p>
<pre><code class="language-bash">aws kms decrypt \
--ciphertext-blob fileb://&lt;(echo &quot;encryptedBase64EncodedString&quot; | base64 --decode)
--output text \
--query Plaintext | base64 --decode</code></pre>
</div></div></div><script id="__NEXT_DATA__" type="application/json">{"dataManager":"[]","props":{"pageProps":{}},"page":"/articles","query":{"attributes":{"title":"KMS Encryption and Decryption","description":"Encrypt and decrypt secure text, passwords and keys using AWS KMS service using CLI"},"body":"\u003ch1 id=\"encrypt-and-decrypt-keys-using-aws-kms\"\u003eEncrypt and Decrypt Keys using AWS KMS\u003c/h1\u003e\n\u003ch2 id=\"encryption\"\u003eEncryption\u003c/h2\u003e\n\u003cp\u003eFor this we need to create a \u0026quot;Customer Managed Key\u0026quot; using either console or CLI, or any other programmatic way. Once we do that, we obtain a \u003ccode\u003ekey-id\u003c/code\u003e to use for encryption. We do not require \u003ccode\u003ekey-id\u003c/code\u003e for decryption. The reason is that, the encrypted hash will be self sufficiently having all the required data for decryption. We can set alias name and description for the keys along with tags for easy identification of the key\u0026#39;s purpose.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003eaws kms encrypt \\\n--key-id XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX \\\n--plaintext \u0026quot;secret text for encryption\u0026quot; \\\n--output text \\\n--query CiphertextBlob\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe drawback with above method is, if someone or admin checks the history, it will be visible as clear text and in many organisation it will be a clear violation of security policies. For that, we can store the password in a text file and call that file here. Say,\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003eaws kms encrypt \\\n--key-id XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX \\\n--plaintext fileb://secretfile \\\n--output text \\\n--query CiphertextBlob\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhen we do this, the resulting hash will be \u003ccode\u003ebase64\u003c/code\u003e encoded. If we decode it, it will result in a binary value which we cannot store in yaml file. Or else, we can have the binary string written to a separate file and reference that file in our yaml files.\nFor decoding and storing in a file,\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003eaws kms encrypt \\\n--key-id XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX \\\n--plaintext fileb://secretfile \\\n--output text \\\n--query CiphertextBlob | base64 --decode \u0026gt; binaryFileName\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"decryption\"\u003eDecryption\u003c/h2\u003e\n\u003cp\u003eFor decryption,\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003eaws kms decrypt \\\n--ciphertext-blob fileb://binaryFileName\n--output text \\\n--query Plaintext\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eNote:- Again, the resulting text will be base64 encoded\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eIf you have an encrypted base64 text string to obtain back the original secret key, you can do:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003eaws kms decrypt \\\n--ciphertext-blob fileb://\u0026lt;(echo \u0026quot;encryptedBase64EncodedString\u0026quot; | base64 --decode)\n--output text \\\n--query Plaintext | base64 --decode\u003c/code\u003e\u003c/pre\u003e\n","frontmatter":"title: KMS Encryption and Decryption\ndescription: Encrypt and decrypt secure text, passwords and keys using AWS KMS service using CLI"},"buildId":"c_R24dhd8hjJEXWGIGUO-","nextExport":true}</script><script nomodule="" src="/_next/static/runtime/polyfills-5fa5b8189f4681d353e9.js"></script><script async="" data-next-page="/articles" src="/_next/static/c_R24dhd8hjJEXWGIGUO-/pages/articles.js"></script><script async="" data-next-page="/_app" src="/_next/static/c_R24dhd8hjJEXWGIGUO-/pages/_app.js"></script><script src="/_next/static/runtime/webpack-9369c5c69dbf6d4912cb.js" async=""></script><script src="/_next/static/chunks/commons.b6dc333151af4a74b05a.js" async=""></script><script src="/_next/static/runtime/main-5b3d9dcbbf35909ee5a1.js" async=""></script></body></html>